# coding=utf-8

#a = [' train_test_split\n\u200b\ndigits ']
import sys,io
#sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding='gb18030')
a = ['\n', '\n# ', '分类准确度存在的问题', '\n', '\n', '\n', '如果现在有一个癌症预测系统，输入患者的信息，可以判断是否有癌症。如果只使用分类准确度来评价模型的好坏是否合理？假如此时模型的预测准确度是99.9%，那么是否能认为模型是好的呢？如果癌症产生的概率只有0.1%，那就意味着这个癌症预测系统只有预测所有人都是健康，即可达到99.9%的准确率。那么此时还认为模型是好的嘛？假如更加极端一点，如果癌症产生的概率只有0.01%，那就意味着这个癌症预测系统只有预测所有人都是健康，即可达到99.99%的准确率。到这里，就能大概理解分类准确度评价模型存在的问题。什么时候才会出现这样的问题呢？这就是对于', '**', '极度偏斜的数据（Skewed Data）', '**', '，也就样本数据极度不平衡的情况下，只使用分类准确度是远远不够的。因此需要引进更多的指标。', ' 首先使用', '**', '混淆矩阵（Confusion Matrix）', '**', ' 做进一步的分析。首先针对二分类问题，进行混淆矩阵分析。我们通过样本的采集，能够直接知道真实情况下，哪些数据结果是 ', '**', 'positive', '**', '，哪些结果是 ', '**', 'negative', '**', '。', '\n', '\n', '\n', '混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。', '\n', '\n', '\n', '介绍几个概念：', ' ', '\n![./figures\\a78f3721e4b2426f8359de1b6a0324cb.png](./figures\\a78f3721e4b2426f8359de1b6a0324cb.png)\n', '\n', '\n', '\n', 'TN（True Negative）：真实值Negative，预测Negative', ' FP（False Positive）： 真实值Negative，预测Positive', ' FN（False Negative）：真实值Positive，预测Negative', ' TP（True Positive）： 真实值Positive，预测Positive', '\n', '\n', '\n', '其实，就是希望右斜对角线越多越好就，即TN和TP的数量越多越好，也由此会延伸出更多的二级指标。', ' 假设还是癌症预测，先测试了10000个人，预测结果如下：', ' ', '\n![./figures\\18529f726fa24bc7968631b1837ec2d4.png](./figures\\18529f726fa24bc7968631b1837ec2d4.png)\n', ' TN：9978个人真实没有癌症，预测没有癌症；FP：12个人真实没有癌症，预测有癌症；FN：2个人真实有癌症，预测没有癌症；TP：8个人真实有癌症，预测也有癌症。', '\n', '\n', '\n# ', '精准率和召回率', '\n', '\n', '\n', '首先介绍由混淆矩阵延伸出来的两个二级指标：', '\n', '\n## ', '精准率（precision）', '\n', '\n', '\n', '\n![./figures\\cba4bd8bd02a46f4bfe7c189dba2b95a.png](./figures\\cba4bd8bd02a46f4bfe7c189dba2b95a.png)\n', ' 由第一节中的实际案例，精准率=8/（8+12）=40%，这是因为通常在有偏的样本集中更加关注重点。精准率就是对更加关注的事件进行一个评判，比如例子中我们把预测有癌症作为关注的重点，就是在预测患有癌症的患者中真实患有癌症的概率。', '\n', '\n## ', '召回率 （recall）', '\n', '\n', '\n', '\n![./figures\\1a27f2fd66ac42029ed62e82a7e44dc7.png](./figures\\1a27f2fd66ac42029ed62e82a7e44dc7.png)\n', ' 由第一节中的实际案例，召回率=8/（8+2）=80%，就是在10个癌症患者中预测出了8个，80%就是召回率。', '\n', '\n## ', '编程实现精准率和召回率', '\n', '\n', '\n', '首先生成样本不均衡的数据：', '\n', '\n```python\n', 'import', ' numpy ', 'as', ' np\n', 'from', ' sklearn ', 'import', ' datasets\n', 'from', ' sklearn', '.', 'model_selection ', 'import', ' train_test_split\n\u200b\ndigits ', '=', ' datasets', '.', 'load_digits', '(', ')', '\nx ', '=', ' digits', '.', 'data\ny ', '=', ' digits', '.', 'target', '.', 'copy', '(', ')', '\n', '# 生成不平衡的数据', '\ny', '[', 'digits', '.', 'target', '==', '9', ']', ' ', '=', ' ', '1', '\ny', '[', 'digits', '.', 'target', '!=', '9', ']', ' ', '=', ' ', '0', '\n\u200b\nx_train', ',', ' x_test', ',', ' y_train', ',', ' y_test ', '=', ' train_test_split', '(', 'x', ',', ' y', ',', ' random_state', '=', '666', ')', '\n\u200b\n', 'from', ' sklearn', '.', 'linear_model ', 'import', ' LogisticRegression\n\u200b\nlog_reg ', '=', ' LogisticRegression', '(', ')', '\nlog_reg', '.', 'fit', '(', 'x_train', ',', ' y_train', ')', '\nlog_reg', '.', 'score', '(', 'x_test', ',', ' y_test', ')', '\n', '# 0.9755555555555555', '\nlog_reg_predict ', '=', ' log_reg', '.', 'predict', '(', 'x_test', ')', '\n', 'def', ' ', 'TN', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    ', 'assert', ' ', 'len', '(', 'y_true', ')', ' ', '==', ' ', 'len', '(', 'y_predict', ')', '\n    ', 'return', ' np', '.', 'sum', '(', '(', 'y_true ', '==', ' ', '0', ')', ' ', '&', ' ', '(', 'y_predict ', '==', ' ', '0', ')', ')', '\n\u200b\n', 'def', ' ', 'FP', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    ', 'assert', ' ', 'len', '(', 'y_true', ')', ' ', '==', ' ', 'len', '(', 'y_predict', ')', '\n    ', 'return', ' np', '.', 'sum', '(', '(', 'y_true ', '==', ' ', '0', ')', ' ', '&', ' ', '(', 'y_predict ', '==', ' ', '1', ')', ')', '\n\u200b\n', 'def', ' ', 'FN', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    ', 'assert', ' ', 'len', '(', 'y_true', ')', ' ', '==', ' ', 'len', '(', 'y_predict', ')', '\n    ', 'return', ' np', '.', 'sum', '(', '(', 'y_true ', '==', ' ', '1', ')', ' ', '&', ' ', '(', 'y_predict ', '==', ' ', '0', ')', ')', '\n\u200b\n', 'def', ' ', 'TP', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    ', 'assert', ' ', 'len', '(', 'y_true', ')', ' ', '==', ' ', 'len', '(', 'y_predict', ')', '\n    ', 'return', ' np', '.', 'sum', '(', '(', 'y_true ', '==', ' ', '1', ')', ' ', '&', ' ', '(', 'y_predict ', '==', ' ', '1', ')', ')', '\n\u200b\nTN', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 403', '\nFP', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 2', '\nFN', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 9', '\nTP', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 36', '\n', '# 混淆矩阵的实现', '\n', 'def', ' ', 'confusion_matrix', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    ', 'return', ' np', '.', 'array', '(', '[', '\n        ', '[', 'TN', '(', 'y_test', ',', ' log_reg_predict', ')', ',', ' FP', '(', 'y_test', ',', ' log_reg_predict', ')', ']', ',', '\n        ', '[', 'FN', '(', 'y_test', ',', ' log_reg_predict', ')', ',', ' TP', '(', 'y_test', ',', ' log_reg_predict', ')', ']', ',', '\n    ', ']', ')', '\nconfusion_matrix', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# array([[403,   2],', '\n', '#       [  9,  36]])', '\n', '# 精准率', '\n', 'def', ' ', 'precison_score', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    tp ', '=', ' TP', '(', 'y_test', ',', ' log_reg_predict', ')', '\n    fp ', '=', ' FP', '(', 'y_test', ',', ' log_reg_predict', ')', '\n    ', 'try', ':', '\n        ', 'return', ' tp', '/', '(', 'tp', '+', 'fp', ')', '\n    ', 'except', ':', '\n        ', 'return', ' ', '0.0', '\n\u200b\n', '# 召回率', '\n', 'def', ' ', 'recall_score', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    tp ', '=', ' TP', '(', 'y_test', ',', ' log_reg_predict', ')', '\n    fn ', '=', ' FN', '(', 'y_test', ',', ' log_reg_predict', ')', '\n    ', 'try', ':', '\n        ', 'return', ' tp', '/', '(', 'tp', '+', 'fn', ')', '\n    ', 'except', ':', '\n        ', 'return', ' ', '0.0', '\n\u200b\nprecison_score', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 0.9473684210526315', '\nrecall_score', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 0.8', '\n', '```\n', '\n', '\n## ', 'sklearn中精准率和召回率的实现', '\n', '\n', '\n```python\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' confusion_matrix\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' precision_score\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' recall_score\n\u200b\nconfusion_matrix', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# array([[403,   2],', '\n', '#        [  9,  36]], dtype=int64)', '\nprecision_score', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 0.9473684210526315', '\nrecall_score', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 0.8', '\n', '```\n', '\n', '\n', '在现实的使用过程中，这两个评价指标可能会出现一些矛盾，比如有些时候使用这种方法精准率高但召回率低，使用另外一种方法精准率低召回率高，那么如何权衡两种指标呢？', ' ', '\n![./figures\\651f8a10ec664e9fa4822ab3812ba23f.png](./figures\\651f8a10ec664e9fa4822ab3812ba23f.png)\n', ' 有时候比较注重精准率，比如股票预测，有时候更加注重召回率，比如病人诊断。对于不同的应用场景，偏好不同的指标。而往往有些时候可能并不是这么的极端，既需要保证精准率又需要保证召回率？由此引出一个新的指标：', '**', 'F1-score', '**', '。', '\n', '\n', '\n# ', 'F1-score', '\n', '\n', '\n', '\n', 'F1分数（F1 Score），是统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的精确率和召回率。F1分数可以看作是模型精确率和召回率的一种调和平均，它的最大值是1，最小值是0。', '\n', '\n', '\n', '\n![./figures\\980d5ddc0dac454b8d134c7c334709fa.png](./figures\\980d5ddc0dac454b8d134c7c334709fa.png)\n', ' 编程实现：', '\n', '\n```python\n', 'from', ' sklearn ', 'import', ' datasets\n', 'from', ' sklearn', '.', 'model_selection ', 'import', ' train_test_split\n', 'from', ' sklearn', '.', 'linear_model ', 'import', ' LogisticRegression\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' precision_score\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' recall_score\n\u200b\ndigits ', '=', ' datasets', '.', 'load_digits', '(', ')', '\nx ', '=', ' digits', '.', 'data\ny ', '=', ' digits', '.', 'target', '.', 'copy', '(', ')', '\n', '# 生成不平衡的数据', '\ny', '[', 'digits', '.', 'target', '==', '9', ']', ' ', '=', ' ', '1', '\ny', '[', 'digits', '.', 'target', '!=', '9', ']', ' ', '=', ' ', '0', '\nx_train', ',', ' x_test', ',', ' y_train', ',', ' y_test ', '=', ' train_test_split', '(', 'x', ',', ' y', ',', ' random_state', '=', '666', ')', '\n\u200b\nlog_reg ', '=', ' LogisticRegression', '(', ')', '\nlog_reg', '.', 'fit', '(', 'x_train', ',', ' y_train', ')', '\nlog_reg', '.', 'score', '(', 'x_test', ',', ' y_test', ')', '\n', '# 0.9755555555555555', '\nlog_reg_predict ', '=', ' log_reg', '.', 'predict', '(', 'x_test', ')', '\n\u200b\n', 'def', ' ', 'f1_score', '(', 'precision', ',', ' recall', ')', ':', '\n    ', 'try', ':', '\n        ', 'return', ' ', '2', ' ', '*', ' precision ', '*', ' recall ', '/', ' ', '(', 'precision ', '+', ' recall', ')', '\n    ', 'except', ':', '\n        ', 'return', ' ', '0.0', '\n\u200b\nprecision_score', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 0.9473684210526315', '\nrecall_score', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 0.8', '\nf1_score', '(', 'precision_score', '(', 'y_test', ',', ' log_reg_predict', ')', ',', ' recall_score', '(', 'y_test', ',', ' log_reg_predict', ')', ')', '\n', '# 0.8674698795180723', '\n', '```\n', '\n', '\n', 'sklearn中的实现：', '\n', '\n```python\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' f1_score\n\u200b\nf1_score', '(', 'y_test', ',', ' log_reg_predict', ')', '\n', '# 0.8674698795180723', '\n', '```\n', '\n', '\n', '通过上述例子进行一个对比：准确度：0.9755555555555555，精准率：0.9473684210526315，召回率：0.8，调和平均值f1-score：0.8674698795180723。精准率和召回率任何一个值比较低就会拉低整体分数。', '\n', '\n```python\n', 'def', ' ', 'f1_score', '(', 'precision', ',', ' recall', ')', ':', '\n    ', 'try', ':', '\n        ', 'return', ' ', '2', ' ', '*', ' precision ', '*', ' recall ', '/', ' ', '(', 'precision ', '+', ' recall', ')', '\n    ', 'except', ':', '\n        ', 'return', ' ', '0.0', ' \n    \nprecision ', '=', ' ', '0.5', '\nrecall ', '=', ' ', '0.5', '\nf1_score', '(', 'precision', ',', ' recall', ')', '\n', '# 0.5', '\nprecision ', '=', ' ', '0.1', '\nrecall ', '=', ' ', '0.9', '\nf1_score', '(', 'precision', ',', ' recall', ')', '\n', '# 0.18000000000000002', '\n', '```\n', '\n', '\n', '\n# ', '精准率与召回率的平衡', '\n', '\n', '\n', '其实这是一对矛盾的指标，精准率高召回率就低，精准率低召回率就高，那么如何平衡呢？首先回顾一下逻辑回归算法', ' ', '\n![./figures\\c364d174588147bda66d054ef6f0ef78.png](./figures\\c364d174588147bda66d054ef6f0ef78.png)\n', ' 决策边界：', ' ', '\n![./figures\\a77c6d578bff4886887babd1d1b3220a.png](./figures\\a77c6d578bff4886887babd1d1b3220a.png)\n', ' 解析几何中，其实这就是一条直线，这条直线就是分类中的决策边界，在直线的一侧为0，另一侧为1，那么为什么要取0呢？如果取任意值呢？', ' 决策边界：', ' ', '\n![./figures\\b523aa38f4fc45819469d25bbbec8352.png](./figures\\b523aa38f4fc45819469d25bbbec8352.png)\n', ' 此时就是相当于平移决策边界，从而影响分类结果。', '\n', '\n```python\n', 'import', ' numpy ', 'as', ' np\n', 'import', ' matplotlib', '.', 'pyplot ', 'as', ' plt\n', 'from', ' sklearn ', 'import', ' datasets\n', 'from', ' sklearn', '.', 'model_selection ', 'import', ' train_test_split\n', 'from', ' sklearn', '.', 'linear_model ', 'import', ' LogisticRegression\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' confusion_matrix\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' precision_score\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' recall_score\n\u200b\ndigits ', '=', ' datasets', '.', 'load_digits', '(', ')', '\nx ', '=', ' digits', '.', 'data\ny ', '=', ' digits', '.', 'target', '.', 'copy', '(', ')', '\n', '# 生成不平衡的数据', '\ny', '[', 'digits', '.', 'target', '==', '9', ']', ' ', '=', ' ', '1', '\ny', '[', 'digits', '.', 'target', '!=', '9', ']', ' ', '=', ' ', '0', '\nx_train', ',', ' x_test', ',', ' y_train', ',', ' y_test ', '=', ' train_test_split', '(', 'x', ',', ' y', ',', ' random_state', '=', '666', ')', '\n\u200b\nlog_reg ', '=', ' LogisticRegression', '(', ')', '\nlog_reg', '.', 'fit', '(', 'x_train', ',', ' y_train', ')', '\n', '# 默认使用0作为决策边界。那如何对决策边界进行平移呢？', '\ny_predict ', '=', ' log_reg', '.', 'predict', '(', 'x_test', ')', '\n\u200b\nconfusion_matrix', '(', 'y_test', ',', ' y_predict', ')', '\n', '# array([[403,   2],', '\n', '#       [  9,  36]], dtype=int64)', '\nprecision_score', '(', 'y_test', ',', ' y_predict', ')', '\n', '# 0.9473684210526315', '\nrecall_score', '(', 'y_test', ',', ' y_predict', ')', '\n', '# 0.8', '\n', '```\n', '\n', '\n', '首先我们要知道预测结果中的最大值最小值。然后就可以根据自己的需求选择合适的threshold，对数据进行预测。', '\n', '\n```python\n', 'log_reg', '.', 'decision_function', '(', 'x_test', ')', '\n', '# 太多了，显示前10个', '\nlog_reg', '.', 'decision_function', '(', 'x_test', ')', '[', ':', '10', ']', '\n', '```\n', '\n', '\n', '输出结果：', '\n', '\n```python\n', 'array', '(', '[', '-', '22.05700117', ',', ' ', '-', '33.02940957', ',', ' ', '-', '16.21334087', ',', ' ', '-', '80.3791447', ' ', ',', '\n       ', '-', '48.25125396', ',', ' ', '-', '24.54005629', ',', ' ', '-', '44.39168773', ',', ' ', '-', '25.04292757', ',', '\n        ', '-', '0.97829292', ',', ' ', '-', '19.7174399', ' ', ']', ')', '\nlog_reg', '.', 'predict', '(', 'x_test', ')', '[', ':', '10', ']', '\n', '# array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])', '\n', '```\n', '\n', '\n', '通过前10个可以发现都是负数，预测结果都是0，这是因为predict默认使用0作为分类边界，小于0的都为0，大于0的为1。', '\n', '\n```python\n', 'decision_score ', '=', '  log_reg', '.', 'decision_function', '(', 'x_test', ')', '\nnp', '.', 'min', '(', 'decision_score', ')', '\n', '# -85.68608522646575', '\nnp', '.', 'max', '(', 'decision_score', ')', '\n', '# 19.8895858799022', '\n', '```\n', '\n', '\n', '首先选择threshold=5，', '\n', '\n```python\n', 'y_predict2 ', '=', ' np', '.', 'array', '(', 'decision_score ', '>=', ' ', '5', ',', ' dtype', '=', "'int'", ')', '\nconfusion_matrix', '(', 'y_test', ',', ' y_predict2', ')', '\n', '# array([[404,   1],', '\n', '#        [ 21,  24]], dtype=int64)', '\nprecision_score', '(', 'y_test', ',', ' y_predict2', ')', '\n', '# 0.96', '\nrecall_score', '(', 'y_test', ',', ' y_predict2', ')', '\n', '# 0.5333333333333333', '\n', '```\n', '\n', '\n', '如果选择threshold=-5呢？', '\n', '\n```python\n', 'y_predict3 ', '=', ' np', '.', 'array', '(', 'decision_score ', '>=', ' ', '-', '5', ',', ' dtype', '=', "'int'", ')', '\nconfusion_matrix', '(', 'y_test', ',', ' y_predict3', ')', '\n', '# array([[390,  15],', '\n', '#        [  5,  40]], dtype=int64)', '\nprecision_score', '(', 'y_test', ',', ' y_predict3', ')', '\n', '# 0.7272727272727273', '\nrecall_score', '(', 'y_test', ',', ' y_predict3', ')', '\n', '# 0.8888888888888888', '\n', '```\n', '\n', '\n', '至此，使用decision_function这个函数改变了逻辑回归分类的阈值，相应的可以对比不同阈值情况下精准率和召回率的制约关系，那么具体做一个分类算法的时候，如何选取这个threshold去平衡精准率和召回率呢？由此引出精准率与召回率曲线。', '\n', '\n', '\n# ', '精准率与召回率曲线（P-R曲线）', '\n', '\n', '\n', 'PR曲线的两个指标都聚焦于正例。', '\n', '\n## ', '编程实现PR曲线', '\n', '\n', '\n```python\n', 'import', ' numpy ', 'as', ' np\n', 'import', ' matplotlib', '.', 'pyplot ', 'as', ' plt\n', 'from', ' sklearn ', 'import', ' datasets\n', 'from', ' sklearn', '.', 'model_selection ', 'import', ' train_test_split\n', 'from', ' sklearn', '.', 'linear_model ', 'import', ' LogisticRegression\n\u200b\ndigits ', '=', ' datasets', '.', 'load_digits', '(', ')', '\nx ', '=', ' digits', '.', 'data\ny ', '=', ' digits', '.', 'target', '.', 'copy', '(', ')', '\n', '# 生成不平衡的数据', '\ny', '[', 'digits', '.', 'target', '==', '9', ']', ' ', '=', ' ', '1', '\ny', '[', 'digits', '.', 'target', '!=', '9', ']', ' ', '=', ' ', '0', '\nx_train', ',', ' x_test', ',', ' y_train', ',', ' y_test ', '=', ' train_test_split', '(', 'x', ',', ' y', ',', ' random_state', '=', '666', ')', '\nlog_reg ', '=', ' LogisticRegression', '(', ')', '\nlog_reg', '.', 'fit', '(', 'x_train', ',', ' y_train', ')', '\n\u200b\ndecision_scores ', '=', ' log_reg', '.', 'decision_function', '(', 'x_test', ')', '\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' precision_score\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' recall_score\n\u200b\nprecisions ', '=', ' ', '[', ']', '\nrecalls ', '=', ' ', '[', ']', '\nthresholds ', '=', ' np', '.', 'arange', '(', 'np', '.', 'min', '(', 'decision_scores', ')', ',', ' np', '.', 'max', '(', 'decision_scores', ')', ')', '\n\u200b\n', 'for', ' threshold ', 'in', ' thresholds', ':', '\n    y_predict ', '=', ' np', '.', 'array', '(', 'decision_scores ', '>=', ' threshold', ',', ' dtype', '=', "'int'", ')', '\n    precisions', '.', 'append', '(', 'precision_score', '(', 'y_test', ',', ' y_predict', ')', ')', '\n    recalls', '.', 'append', '(', 'recall_score', '(', 'y_test', ',', ' y_predict', ')', ')', ' \n    \nplt', '.', 'plot', '(', 'thresholds', ',', ' precisions', ',', ' label', '=', "'precision'", ')', '\nplt', '.', 'plot', '(', 'thresholds', ',', ' recalls', ',', ' label', '=', "'recall'", ')', '\nplt', '.', 'legend', '(', ')', '\nplt', '.', 'show', '(', ')', '\n', '```\n', '\n', '\n', '\n![./figures\\de6ca5b5d660424bb1af71edd913fe5e.png](./figures\\de6ca5b5d660424bb1af71edd913fe5e.png)\n', ' 那么现在有了这个图，就可以去选择合适的阈值去平衡精准率和召回率。如果需要保持准确率为90%以上，能有多少召回率？从而确定合适的阈值。', '\n', '\n```python\n', 'plt', '.', 'plot', '(', 'precisions', ',', ' recalls', ')', '\nplt', '.', 'show', '(', ')', '\n', '```\n', '\n', '\n', '\n![./figures\\bf8735cc60024ee5a92d44012bb91852.png](./figures\\bf8735cc60024ee5a92d44012bb91852.png)\n', ' 通过图中的趋势很显然随着精准率的提高，召回率在不断的下降。这也再一次印证了精准流程和召回率是互相制约互相平衡的，而在图中急剧下降的点大概就是精准率和召回率平衡的最佳点。', '\n', '\n## ', 'sklearn中实现P-R曲线', '\n', '\n', '\n```python\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' precision_recall_curve\n\u200b\nprecisions', ',', ' recalls', ',', ' thresholds ', '=', ' precision_recall_curve', '(', 'y_test', ',', ' decision_scores', ')', '\nprecisions', '.', 'shape\n', '# (145,)', '\nrecalls', '.', 'shape\n', '# (145,)', '\nthresholds', '.', 'shape\n', '# (144,)', '\n', '```\n', '\n', '\n', '通过上面程序输出结果可以发现返回的精准率和召回率与阈值的长度不一致，这是因为在sklearn中会自动取合适的阈值范围内计算准确率和召回率，而且默认的最大值为1和最小值为0，没有对应的threshold，因此这就是为什么thresholds比precisions和recalls长度少1，因此在绘图的时候需要注意。', '\n', '\n```python\n', 'plt', '.', 'plot', '(', 'thresholds', ',', ' precisions', '[', ':', '-', '1', ']', ')', '\nplt', '.', 'plot', '(', 'thresholds', ',', ' recalls', '[', ':', '-', '1', ']', ')', '\nplt', '.', 'show', '(', ')', '\n', '```\n', '\n', '\n', '\n![./figures\\c191376990d34ff6b6d0d6a98180ed1b.png](./figures\\c191376990d34ff6b6d0d6a98180ed1b.png)\n', ' 通过这两条曲线对比自己编程实现的精准率和召回率曲线大致相同，有着略微的差异，这是因为sklearn中对阈值进行了处理,会自动选取最重要的那部分。', '\n', '\n```python\n', 'plt', '.', 'plot', '(', 'precisions', ',', ' recalls', ')', '\nplt', '.', 'show', '(', ')', '\n', '```\n', '\n', '\n', '\n![./figures\\09e8527ab00f4578bde0318bb318c51b.png](./figures\\09e8527ab00f4578bde0318bb318c51b.png)\n', '\n', '\n## ', '总结', '\n', '\n', '\n', '通过精准率和召回率曲线，可以确定合理的阈值去平衡精准率与召回率他们之间的变化关系。而PR曲线中急剧下降的点大概就是最佳平衡点。最后假如使用两种不同的算法绘制出的PR曲线如下图所示，那么哪种算法更优呢？', ' ', '\n![./figures\\8bf21d5556004e19bd6cae32eb429a44.png](./figures\\8bf21d5556004e19bd6cae32eb429a44.png)\n', ' 很显然，外面那根曲线上的每一个点都比里面那根曲线的precisions和recalls大，所以整体来说如果PR曲线更靠外，也就更好，因此也可以作为选择算法选择超参数的一种指标。其实就是PR曲线下的面积，来衡量模型的优劣，但是一般情况下都会使用另外一种曲线下的面积。由曲线的下的面积，引出下一个知识点ROC曲线。', '\n', '\n', '\n# ', 'ROC曲线', '\n', '\n', '\n', '\n', 'ROC曲线(Receiver Operation Characteristic', ' Curve)，描述TPR和FPR之间的关系。接受者操作特性曲线是指在特定刺激条件下，以被试在不同判断标准下所得的虚报概率P（y/N）为横坐标，以击中概率P（y/SN）为纵坐标，画得的各点的连线。', '\n', '\n', '\n', '\n![./figures\\725dc72dc7c742f18a957155ac7363df.png](./figures\\725dc72dc7c742f18a957155ac7363df.png)\n', ' 编程实现：', '\n', '\n```python\n', 'import', ' numpy ', 'as', ' np\n', 'from', ' sklearn ', 'import', ' datasets\n', 'from', ' sklearn', '.', 'model_selection ', 'import', ' train_test_split\n', 'import', ' matplotlib', '.', 'pyplot ', 'as', ' plt\n\u200b\n', 'def', ' ', 'TN', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    ', 'assert', ' ', 'len', '(', 'y_true', ')', ' ', '==', ' ', 'len', '(', 'y_predict', ')', '\n    ', 'return', ' np', '.', 'sum', '(', '(', 'y_true ', '==', ' ', '0', ')', ' ', '&', ' ', '(', 'y_predict ', '==', ' ', '0', ')', ')', '\n\u200b\n', 'def', ' ', 'FP', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    ', 'assert', ' ', 'len', '(', 'y_true', ')', ' ', '==', ' ', 'len', '(', 'y_predict', ')', '\n    ', 'return', ' np', '.', 'sum', '(', '(', 'y_true ', '==', ' ', '0', ')', ' ', '&', ' ', '(', 'y_predict ', '==', ' ', '1', ')', ')', '\n\u200b\n', 'def', ' ', 'FN', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    ', 'assert', ' ', 'len', '(', 'y_true', ')', ' ', '==', ' ', 'len', '(', 'y_predict', ')', '\n    ', 'return', ' np', '.', 'sum', '(', '(', 'y_true ', '==', ' ', '1', ')', ' ', '&', ' ', '(', 'y_predict ', '==', ' ', '0', ')', ')', '\n\u200b\n', 'def', ' ', 'TP', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    ', 'assert', ' ', 'len', '(', 'y_true', ')', ' ', '==', ' ', 'len', '(', 'y_predict', ')', '\n    ', 'return', ' np', '.', 'sum', '(', '(', 'y_true ', '==', ' ', '1', ')', ' ', '&', ' ', '(', 'y_predict ', '==', ' ', '1', ')', ')', '\n\u200b\n', 'def', ' ', 'TPR', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    tp ', '=', ' TP', '(', 'y_true', ',', ' y_predict', ')', '\n    fn ', '=', ' FN', '(', 'y_true', ',', ' y_predict', ')', '\n    ', 'try', ':', '\n        ', 'return', ' tp ', '/', ' ', '(', 'tp ', '+', ' fn', ')', '\n    ', 'except', ':', '\n        ', 'return', ' ', '0.0', '\n    \n', 'def', ' ', 'FPR', '(', 'y_true', ',', ' y_predict', ')', ':', '\n    fp ', '=', ' FP', '(', 'y_true', ',', ' y_predict', ')', '\n    tn ', '=', ' TN', '(', 'y_true', ',', ' y_predict', ')', '\n    ', 'try', ':', '\n        ', 'return', ' fp ', '/', ' ', '(', 'fp ', '+', ' tn', ')', '\n    ', 'except', ':', '\n        ', 'return', ' ', '0.0', '\n', 'import', ' numpy ', 'as', ' np\n', 'from', ' sklearn ', 'import', ' datasets\n', 'from', ' sklearn', '.', 'model_selection ', 'import', ' train_test_split\n\u200b\ndigits ', '=', ' datasets', '.', 'load_digits', '(', ')', '\nx ', '=', ' digits', '.', 'data\ny ', '=', ' digits', '.', 'target', '.', 'copy', '(', ')', '\n', '# 生成不平衡的数据', '\ny', '[', 'digits', '.', 'target', '==', '9', ']', ' ', '=', ' ', '1', '\ny', '[', 'digits', '.', 'target', '!=', '9', ']', ' ', '=', ' ', '0', '\n\u200b\nx_train', ',', ' x_test', ',', ' y_train', ',', ' y_test ', '=', ' train_test_split', '(', 'x', ',', ' y', ',', ' random_state', '=', '666', ')', '\n\u200b\n', 'from', ' sklearn', '.', 'linear_model ', 'import', ' LogisticRegression\n\u200b\nlog_reg ', '=', ' LogisticRegression', '(', ')', '\nlog_reg', '.', 'fit', '(', 'x_train', ',', ' y_train', ')', '\nlog_reg', '.', 'score', '(', 'x_test', ',', ' y_test', ')', '\n', '# 0.9755555555555555', '\nlog_reg_predict ', '=', ' log_reg', '.', 'predict', '(', 'x_test', ')', '\n\u200b\ndecision_scores ', '=', ' log_reg', '.', 'decision_function', '(', 'x_test', ')', '\n\u200b\nfprs ', '=', ' ', '[', ']', '\ntprs ', '=', ' ', '[', ']', '\nthresholds ', '=', ' np', '.', 'arange', '(', 'np', '.', 'min', '(', 'decision_scores', ')', ',', ' np', '.', 'max', '(', 'decision_scores', ')', ')', '\n\u200b\n', 'for', ' threshold ', 'in', ' thresholds', ':', '\n    y_predict ', '=', ' np', '.', 'array', '(', 'decision_scores ', '>=', ' threshold', ',', ' dtype', '=', "'int'", ')', '\n    fprs', '.', 'append', '(', 'FPR', '(', 'y_test', ',', ' y_predict', ')', ')', '\n    tprs', '.', 'append', '(', 'TPR', '(', 'y_test', ',', ' y_predict', ')', ')', '\n    \nplt', '.', 'plot', '(', 'fprs', ',', ' tprs', ')', '\nplt', '.', 'show', '(', ')', '\n', '```\n', '\n', '\n', '\n![./figures\\c1c4df2a3b0d4e729a0a878e99cbf60e.png](./figures\\c1c4df2a3b0d4e729a0a878e99cbf60e.png)\n', ' sklearn中ROC曲线的实现：', '\n', '\n```python\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' roc_curve\n\u200b\nfprs', ',', ' tprs', ',', ' thresholds ', '=', ' roc_curve', '(', 'y_test', ',', ' decision_scores', ')', '\nplt', '.', 'plot', '(', 'fprs', ',', ' tprs', ')', '\nplt', '.', 'show', '(', ')', '\n', '```\n', '\n', '\n', '\n![./figures\\ccebedf514ea4baebb32d89f06f623e7.png](./figures\\ccebedf514ea4baebb32d89f06f623e7.png)\n', ' ROC曲线随着fpr的增大，tpr也在增大，通常更加关注的是曲线下的面积，如何计算曲线下的面积呢？', '\n', '\n```python\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' roc_auc_score\n', '# area under curve', '\nroc_auc_score', '(', 'y_test', ',', ' decision_scores', ')', '\n', '# 0.9830452674897119', '\n', '```\n', '\n', '\n', '曲线下的面积越大，说明模型的分类效果越好，这是因为在ROC曲线刚开始，fpr较低（预测为1的错误越低）的时候，tpr越大（预测为1正确的越多），曲线下的面积越大，分类算法的模型也就更好。 由输出结果可以发现ROC的AUC值对不均衡样本不是那么敏感，因此对于极度有偏的数据集查看模型的精准率和召回率曲线还是很有必要的，ROC的AUC的主要应用是比较模型或者算法的优劣。', ' ', '\n![./figures\\772937056a694267bbd2710d8f1bbd6f.png](./figures\\772937056a694267bbd2710d8f1bbd6f.png)\n', '\n', '\n', '\n# ', '多分类问题中的混淆矩阵', '\n', '\n', '\n```python\n', 'import', ' numpy ', 'as', ' np\n', 'from', ' sklearn ', 'import', ' datasets\n', 'from', ' sklearn', '.', 'model_selection ', 'import', ' train_test_split\n\ndigits ', '=', ' datasets', '.', 'load_digits', '(', ')', '\nx ', '=', ' digits', '.', 'data\ny ', '=', ' digits', '.', 'target\n\nx_train', ',', ' x_test', ',', ' y_train', ',', ' y_test ', '=', ' train_test_split', '(', 'x', ',', ' y', ',', ' test_size', '=', '0.8', ',', ' random_state', '=', '666', ')', '\n\n', 'from', ' sklearn', '.', 'linear_model ', 'import', ' LogisticRegression\n\nlog_reg ', '=', ' LogisticRegression', '(', ')', '\nlog_reg', '.', 'fit', '(', 'x_train', ',', ' y_train', ')', '\nlog_reg', '.', 'score', '(', 'x_test', ',', ' y_test', ')', '\n\ny_predict ', '=', ' log_reg', '.', 'predict', '(', 'x_test', ')', '\n\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' precision_score\nprecision_score', '(', 'y_test', ',', ' y_predict', ',', ' average', '=', "'micro'", ')', '\n', '# 可以尝试一下precision_score(y_test, y_predict)，默认情况下是不支持多分类准确率预测的，但是可以通过传入超参数解决', '\n', '# 0.93115438108484', '\n', 'from', ' sklearn', '.', 'metrics ', 'import', ' confusion_matrix\nconfusion_matrix', '(', 'y_test', ',', ' y_predict', ')', '\n', '```\n', '\n', '\n', '输出结果：', '\n', '\n```python\n', 'array', '(', '[', '[', '147', ',', '   ', '0', ',', '   ', '1', ',', '   ', '0', ',', '   ', '0', ',', '   ', '1', ',', '   ', '0', ',', '   ', '0', ',', '   ', '0', ',', '   ', '0', ']', ',', '\n       ', '[', '  ', '0', ',', ' ', '123', ',', '   ', '1', ',', '   ', '2', ',', '   ', '0', ',', '   ', '0', ',', '   ', '0', ',', '   ', '3', ',', '   ', '4', ',', '  ', '10', ']', ',', '\n       ', '[', '  ', '0', ',', '   ', '0', ',', ' ', '134', ',', '   ', '1', ',', '   ', '0', ',', '   ', '0', ',', '   ', '0', ',', '   ', '0', ',', '   ', '1', ',', '   ', '0', ']', ',', '\n       ', '[', '  ', '0', ',', '   ', '0', ',', '   ', '0', ',', ' ', '138', ',', '   ', '0', ',', '   ', '5', ',', '   ', '0', ',', '   ', '1', ',', '   ', '5', ',', '   ', '0', ']', ',', '\n       ', '[', '  ', '2', ',', '   ', '5', ',', '   ', '0', ',', '   ', '0', ',', ' ', '139', ',', '   ', '0', ',', '   ', '0', ',', '   ', '3', ',', '   ', '0', ',', '   ', '1', ']', ',', '\n       ', '[', '  ', '1', ',', '   ', '3', ',', '   ', '1', ',', '   ', '0', ',', '   ', '0', ',', ' ', '146', ',', '   ', '0', ',', '   ', '0', ',', '   ', '1', ',', '   ', '0', ']', ',', '\n       ', '[', '  ', '0', ',', '   ', '2', ',', '   ', '0', ',', '   ', '0', ',', '   ', '0', ',', '   ', '1', ',', ' ', '131', ',', '   ', '0', ',', '   ', '2', ',', '   ', '0', ']', ',', '\n       ', '[', '  ', '0', ',', '   ', '0', ',', '   ', '0', ',', '   ', '1', ',', '   ', '0', ',', '   ', '0', ',', '   ', '0', ',', ' ', '132', ',', '   ', '1', ',', '   ', '2', ']', ',', '\n       ', '[', '  ', '1', ',', '   ', '9', ',', '   ', '2', ',', '   ', '3', ',', '   ', '2', ',', '   ', '4', ',', '   ', '0', ',', '   ', '0', ',', ' ', '115', ',', '   ', '4', ']', ',', '\n       ', '[', '  ', '0', ',', '   ', '1', ',', '   ', '0', ',', '   ', '5', ',', '   ', '0', ',', '   ', '3', ',', '   ', '0', ',', '   ', '2', ',', '   ', '2', ',', ' ', '134', ']', ']', ',', ' dtype', '=', 'int64', ')', '\n', '```\n', '\n', '\n', '这样看上去并不直观，绘制一下混淆矩阵。', '\n', '\n```python\n', 'import', ' matplotlib', '.', 'pyplot ', 'as', ' plt\ncfm ', '=', ' confusion_matrix', '(', 'y_test', ',', ' y_predict', ')', '\nplt', '.', 'matshow', '(', 'cfm', ',', ' cmap', '=', 'plt', '.', 'cm', '.', 'gray', ')', '\nplt', '.', 'show', '(', ')', '\n', '```\n', '\n', '\n', '\n![./figures\\9a34b363d4a94ebcbdfef2af17b7bb17.png](./figures\\9a34b363d4a94ebcbdfef2af17b7bb17.png)\n', ' 图中白色方框越亮说明预测正确率越高，但是如果只是显示正确率对于混淆矩阵并能说明什么，是没有意义的，其实我们是想看看预测错误部分。', '\n', '\n```python\n', '# 计算每一行有多少个样本', '\nrow_sums ', '=', ' np', '.', 'sum', '(', 'cfm', ',', ' axis', '=', '1', ')', '\nerr_matrix ', '=', ' cfm ', '/', ' row_sums\n', '# 不关注预测正确的那部分', '\nnp', '.', 'fill_diagonal', '(', 'err_matrix', ',', ' ', '0', ')', '\nerr_matrix\n', '```\n', '\n', '\n', '输出结果：', '\n', '\n```python\n', 'array', '(', '[', '[', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.00735294', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', '\n        ', '0.00657895', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ']', ',', '\n       ', '[', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.00735294', ',', ' ', '0.01342282', ',', ' ', '0', '.', '        ', ',', '\n        ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.02205882', ',', ' ', '0.02857143', ',', ' ', '0.06802721', ']', ',', '\n       ', '[', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.00671141', ',', ' ', '0', '.', '        ', ',', '\n        ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.00714286', ',', ' ', '0', '.', '        ', ']', ',', '\n       ', '[', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', '\n        ', '0.03289474', ',', ' ', '0', '.', '        ', ',', ' ', '0.00735294', ',', ' ', '0.03571429', ',', ' ', '0', '.', '        ', ']', ',', '\n       ', '[', '0.01342282', ',', ' ', '0.03496503', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', '\n        ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.02205882', ',', ' ', '0', '.', '        ', ',', ' ', '0.00680272', ']', ',', '\n       ', '[', '0.00671141', ',', ' ', '0.02097902', ',', ' ', '0.00735294', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', '\n        ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.00714286', ',', ' ', '0', '.', '        ', ']', ',', '\n       ', '[', '0', '.', '        ', ',', ' ', '0.01398601', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', '\n        ', '0.00657895', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.01428571', ',', ' ', '0', '.', '        ', ']', ',', '\n       ', '[', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.00671141', ',', ' ', '0', '.', '        ', ',', '\n        ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.00714286', ',', ' ', '0.01360544', ']', ',', '\n       ', '[', '0.00671141', ',', ' ', '0.06293706', ',', ' ', '0.01470588', ',', ' ', '0.02013423', ',', ' ', '0.01333333', ',', '\n        ', '0.02631579', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0', '.', '        ', ',', ' ', '0.02721088', ']', ',', '\n       ', '[', '0', '.', '        ', ',', ' ', '0.00699301', ',', ' ', '0', '.', '        ', ',', ' ', '0.03355705', ',', ' ', '0', '.', '        ', ',', '\n        ', '0.01973684', ',', ' ', '0', '.', '        ', ',', ' ', '0.01470588', ',', ' ', '0.01428571', ',', ' ', '0', '.', '        ', ']', ']', ')', '\n', '```\n', '\n', '\n', '这个输出就是预测错误部分，整体看上去还是挺费劲的，然后绘制一下这个矩阵。', '\n', '\n```python\n', 'plt', '.', 'matshow', '(', 'err_matrix', ',', ' cmap', '=', 'plt', '.', 'cm', '.', 'gray', ')', '\nplt', '.', 'show', '(', ')', '\n', '```\n', '\n', '\n', '\n![./figures\\ac4c154f91fa497f8f90474fb60692c4.png](./figures\\ac4c154f91fa497f8f90474fb60692c4.png)\n', ' 这个图中整体来说就是越亮的部分就是预测错误越多的地方，比如真值为1却预测成了9，比如真值为8预测成了1，这样就能整体看出犯错的地方在哪里，更加重要的是还能看到犯错的主要原因是什么，比如这个手写数字的识别问题其实就在于数字8和数字1的预测，容易混淆1和9,1和8，其实可以通过调整这些个二分类的阈值来提升多分类任务的准确率，这个微调的过程还是有一定的难度的。通过这样一个混淆矩阵的可视化，进一步分析出问题所在，进而对分类算法进行改进。', ' 其实，一直都在讨论的是如何从算法层面去解决问题，做出改进，但是在机器学习这个领域，很有可能问题并不是出在算法层面，而是有可能处在样本数据层面上，比如数据集的层面上去研究一下数字1、8、9等，从数据的角度去理解为什么机器学习算法或者模型预测错误的原因，很有可能能够总结出新的特征。这也就是特征工程。总之，数据是机器学习的基础，如果没有一个好的数据还谈什么训练模型。对于数据的清理和处理是很关键的！', '\n']

def remove_upprintable_chars(s):
    """移除所有不可见字符"""
    return ''.join(x for x in s if x.isprintable())
a=[
    ' roc_curve\u200bfprs',
    '\u200bdecision_scores ', 
    '=', 
    ' log_reg', 
    '.', 
    'decision_function', 
    '(', 'x_test', ')', 
    '\u200bfprs '
]
b=[]
for item in a:
    print(item,len(item))
    item = item.replace('\u200b','')
    b.append(item)
    print(item,len(item))
